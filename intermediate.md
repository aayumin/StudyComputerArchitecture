# 컴퓨터 구조 자료 - 초급부터 고급까지
## ⭐⭐⭐⭐ ChatGPT가 생성한 학습자료입니다 ⭐⭐⭐⭐

---

## 1. 💻 컴퓨터 시스템의 전체 구성 이해

### 컴퓨터는 어떤 부품으로 구성되어 있을까요?

| 구성요소 | 설명 |
|----------|------|
| **CPU (Central Processing Unit)** | 중앙처리장치. 모든 연산과 제어를 담당하는 컴퓨터의 '뇌' |
| **RAM (Random Access Memory)** | 실행 중인 데이터, 프로그램을 저장하는 공간. '작업용 책상'과 비슷 |
| **SSD/HDD (Storage)** | 장기적인 데이터 저장소. '책장'처럼 저장만 하고 연산은 하지 않음 |
| **GPU (Graphics Processing Unit)** | 그래픽과 병렬 연산을 처리하는 보조 두뇌 |
| **Mainboard (Motherboard)** | 모든 장치를 연결하는 회로판. 각 장치 간 데이터 통로 |
| **I/O Devices (Input/Output)** | 마우스, 키보드, 모니터 등 사용자와 소통하는 장치 |

---

## 2. ⚙️ 명령어와 컴퓨터 동작의 기본 사이클

### 모든 프로그램은 결국 **명령어들의 모음**입니다.

CPU는 다음과 같은 다섯 단계로 명령어를 처리합니다:

1. **Fetch**: 메모리에서 명령어를 가져옴
2. **Decode**: 명령어를 해석함
3. **Execute**: 연산을 수행함
4. **Memory Access**: 메모리와 데이터를 주고받음
5. **Write Back**: 결과를 저장함

이 과정을 반복하며 프로그램이 실행됩니다.

---

## 3. 🧠 CPU의 내부 구조와 작동 원리

### 주요 구성요소

| 컴포넌트 | 설명 |
|----------|------|
| **ALU (Arithmetic Logic Unit)** | 덧셈, 뺄셈, AND, OR, 비교 등 연산 수행 |
| **Control Unit** | 명령어 해석, 내부 부품 제어 신호 생성 |
| **Registers** | CPU 내부의 초고속 저장 공간. 나중에 자세히 설명 |
| **Program Counter (PC)** | 다음 명령어의 주소를 기억 |
| **Cache (캐시 메모리)** | 자주 쓰는 데이터를 저장하는 빠른 임시 공간 |

---

## 🔎 Registers (레지스터)

- **정의**: CPU 내부에 있는 아주 작은 메모리. 데이터를 일시적으로 저장
- **위치**: CPU 칩 안에 내장되어 있음
- **속도**: RAM보다 훨씬 빠름
- **역할**: 연산에 사용할 데이터를 잠깐 보관

| 종류 | 개수 | 예시 |
|------|------|------|
| **General Purpose Registers** | 32개 (MIPS 기준) | `$t0`, `$s1`, `$a0`, `$v0` 등 |
| **Special Registers** | - | `$sp`(stack pointer), `$ra`(return address) 등 |

---

## 4. 🧠 RAM (Random Access Memory)

- 프로그램이 실행될 때 **명령어와 데이터**를 저장하는 임시 저장 공간
- **속도는 빠르지만 전원 끄면 내용이 사라짐**
- 비유: 수학 문제를 풀기 위한 **빈 종이**. 잠시 계산하고 지우는 용도
- 모든 연산은 **RAM에 데이터를 올려놓은 상태에서만 가능**함

---

## 5. ⚡ Cache (캐시 메모리)

- **RAM보다 빠른 저장 공간**으로 CPU에 매우 가깝게 위치함
- **물리적 위치**: CPU 칩 바로 옆 또는 안에 있음
- **이유**: RAM은 멀어서 자주 왕복하면 느림. 그래서 **자주 쓰는 데이터**만 따로 저장해둠
- 비유:
  - **SSD/HDD**: 창고
  - **RAM**: 사무실 책상
  - **Cache**: 책상 위 메모지나 손에 들고 있는 계산기

| 계층 | 설명 |
|------|------|
| **L1 Cache** | 가장 빠름, 용량 작음 |
| **L2 Cache** | 중간 속도, 중간 크기 |
| **L3 Cache** | CPU 코어 간 공유용, 크고 느림 |

---

## 6. 🧮 가상 메모리 (Virtual Memory)

### 💡 가상 메모리는 무엇인가요?

- **RAM 공간이 부족해도 프로그램이 실행될 수 있도록** 도와주는 시스템
- 운영체제가 프로그램마다 **독립된 메모리 공간**을 제공하는 것처럼 속여줌

### 🔧 실제 하드웨어에서는?

- 프로그램이 요청하는 주소는 **가상 주소 (Virtual Address)**
- MMU (Memory Management Unit)가 이를 **물리 주소 (Physical Address)**로 변환함
- 필요 시 **디스크의 일부 공간(Swap)**을 메모리처럼 사용함

### 📦 비유

- 실제 책상(RAM)이 작을 때, 운영체제가 책장을 일부 책상처럼 사용
- 자주 쓰는 내용은 책상(메모리), 안 쓰는 내용은 책장(디스크)에 보관
- MMU가 이걸 관리함 (책 꺼내고 넣는 역할)

---

## 7. 🚀 파이프라인 구조의 이해와 성능 향상

### 🏭 파이프라인(Pipeline) 비유

- 마치 자동차 조립 공장처럼, 여러 명령어가 **동시에 서로 다른 단계에서 실행됨**
- 각 단계는 별도로 독립 실행

### 5단계 파이프라인 구성

| 단계 (영문) | 설명 | 비유 |
|-------------|------|------|
| **IF (Instruction Fetch)** | 메모리에서 명령어를 가져옴 | 메뉴판에서 주문 읽기 |
| **ID (Instruction Decode)** | 어떤 명령인지 해석 | 요리사에게 전달해 해석 |
| **EX (Execute)** | 계산/연산 수행 | 실제 요리 시작 (썰기, 볶기 등) |
| **MEM (Memory Access)** | 메모리에 접근 | 재료 창고에서 소금/설탕 가져오기 |
| **WB (Write Back)** | 결과 저장 | 완성된 요리를 접시에 담기 |

### ⏱️ 예시 타임라인

| Cycle | IF       | ID       | EX       | MEM      | WB       |
|-------|----------|----------|----------|----------|----------|
| 1     | Inst1    |          |          |          |          |
| 2     | Inst2    | Inst1    |          |          |          |
| 3     | Inst3    | Inst2    | Inst1    |          |          |
| 4     | Inst4    | Inst3    | Inst2    | Inst1    |          |
| 5     | Inst5    | Inst4    | Inst3    | Inst2    | Inst1    |

---

## 8. ⚠️ 파이프라인의 문제점과 해결

### 1️⃣ Data Hazard (데이터 위험)

```mips
add $s1, $s2, $s3
sub $s4, $s1, $s5
```

- `$s1 = $s2 + $s3` 결과가 나오기 전에 두 번째 줄에서 `$s1`을 사용
- 이럴 땐 **Stall (지연)**이나 **Forwarding (전방 전달)**로 해결

#### 📘 용어 설명:
- `$s1`: 목적지 레지스터 (결과가 저장됨)
- `$s2`, `$s3`: 연산 대상 레지스터 (더해질 값)
- 물리적으로 CPU 내부 **레지스터 파일(Register File)**에서 작동함

### 2️⃣ Control Hazard (제어 위험)

```mips
beq $t0, $t1, Label
```

- 분기(branch)가 발생할 경우 다음 명령어가 실행될지 불확실
- 해결: **Branch Prediction (분기 예측)**, **Delay Slot (지연 명령 삽입)**

### 3️⃣ Structural Hazard (구조적 위험)

- 두 명령어가 동시에 **같은 하드웨어 자원** 사용 시 충돌 발생
- 해결: 자원 분리 or 명령어 순서 변경

---

## 9. 🧾 Instruction Set Architecture (ISA)

ISA는 CPU가 이해하는 **기계어 명령어 집합 (Instruction Set Architecture)**

| 종류 | 특징 | 예시 |
|------|------|------|
| **RISC (Reduced Instruction Set Computer)** | 단순한 명령어, 고정 길이, 파이프라인에 유리 | MIPS, ARM |
| **CISC (Complex Instruction Set Computer)** | 복잡한 명령어, 코드 양 적음 | x86, x64 |

---

## 10. 🔧 MIPS 구조와 어셈블리 예시

### 📌 레지스터 사용 예시 (MIPS)

| 이름 | 역할 |
|------|------|
| `$a0 ~ $a3` | 함수 인자 전달용 |
| `$t0 ~ $t9` | 임시 계산용 (Temporary) |
| `$s0 ~ $s7` | 저장용 (Saved) |
| `$v0 ~ $v1` | 함수 반환값 저장 |
| `$sp` (Stack Pointer) | 스택 최상단을 가리킴 |
| `$ra` (Return Address) | 함수 호출 복귀 주소 저장 |

### 🧪 예제 명령어 설명

```mips
add $t0, $t1, $t2
```

- `$t0 = $t1 + $t2`  
- `$t1`과 `$t2`는 더할 값이 저장된 **레지스터**
- 결과는 `$t0`에 저장됨

```mips
lw  $s0, 0($s1)
```

- `$s0 = 메모리[$s1 + 0]`
- `$s1`이 가리키는 주소의 데이터를 **로드(load)**해서 `$s0`에 저장

```mips
sw  $s0, 4($s1)
```

- `$s0` 값을 **메모리[$s1 + 4]** 위치에 저장

```mips
beq $t0, $zero, label
```

- `$t0 == 0`이면 **label 위치로 분기 (branch)**

```mips
j target
```

- 무조건 **target 주소로 점프**

---
